<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=6.7.0">


  <link rel="mask-icon" href="/favicon.ico?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="导言 本文是介绍 Java 7 中的 More New I/O APIs for Java (NIO.2) 的两部分文章的第二部分。 正如在 第一部分 中探索的异通道 API 一样， NIO.2 的文件系统用以前 Java 版本处理 I/O 的相关方法，填补了一些重大的空白。 依照 NIO.2 Java 规范要求（JSR 203）： Java 平台早就需要一个文件系统接口而不是 java.io.F">
<meta name="keywords" content="java,基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO2笔记+搬运">
<meta property="og:url" content="https://blog.zzl.ink/posts/481587f.html">
<meta property="og:site_name" content="左良 | Sean&#39;s Blog">
<meta property="og:description" content="导言 本文是介绍 Java 7 中的 More New I/O APIs for Java (NIO.2) 的两部分文章的第二部分。 正如在 第一部分 中探索的异通道 API 一样， NIO.2 的文件系统用以前 Java 版本处理 I/O 的相关方法，填补了一些重大的空白。 依照 NIO.2 Java 规范要求（JSR 203）： Java 平台早就需要一个文件系统接口而不是 java.io.F">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-21T02:02:12.878Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NIO2笔记+搬运">
<meta name="twitter:description" content="导言 本文是介绍 Java 7 中的 More New I/O APIs for Java (NIO.2) 的两部分文章的第二部分。 正如在 第一部分 中探索的异通道 API 一样， NIO.2 的文件系统用以前 Java 版本处理 I/O 的相关方法，填补了一些重大的空白。 依照 NIO.2 Java 规范要求（JSR 203）： Java 平台早就需要一个文件系统接口而不是 java.io.F">






  <link rel="canonical" href="https://blog.zzl.ink/posts/481587f.html">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>NIO2笔记+搬运 | 左良 | Sean's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
 <!-- 页面点击汉字 -->
<script type="text/javascript" src="/js/src/hanzi.js"></script>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">
   
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">左良 | Sean's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">记录轨迹</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
  
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.zzl.ink/posts/481587f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onlyxx">
      <meta itemprop="description" content="write some content">
      <meta itemprop="image" content="https://c.disquscdn.com/uploads/users/32736/3375/avatar92.jpg?1547107149">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左良 | Sean's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">NIO2笔记+搬运

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-24 09:18:00" itemprop="dateCreated datePublished" datetime="2019-01-24T09:18:00+08:00">2019-01-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-21 10:02:12" itemprop="dateModified" datetime="2019-02-21T10:02:12+08:00">2019-02-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/481587f.html#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/481587f.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <img src="https://v2.jinrishici.com/one.svg" title="今日诗词">
      
      

      
        <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p> 本文是介绍 Java 7 中的 More New I/O APIs for Java (NIO.2) 的两部分文章的第二部分。 正如在 第一部分 中探索的异通道 API 一样， NIO.2 的文件系统用以前 Java 版本处理 I/O 的相关方法，填补了一些重大的空白。 依照 NIO.2 Java 规范要求（JSR 203）：</p>
<p>Java 平台早就需要一个文件系统接口而不是 java.io.File 类。 该类不会在平台中以一贯的方式来处理文件名，它不支持高效文件属性访问，不允许复杂应用程序利用可用的文件系统特定特性（比如，符号链接）， 而且，其大多数方法在出错时仅返回失败，而不会提供异常信息。<br>补救措施是 Java 7 试用版中的三个新的文件系统包：</p>
<ul>
<li><code>java.nio.file</code></li>
<li><code>java.nio.file.attribute</code></li>
<li><code>java.nio.file.spi</code></li>
</ul>
<p>本文重点关注这些包中最有用的类：</p>
<ul>
<li><code>java.nio.file.Files</code> 与 <code>java.nio.file.FileVisitor</code> 使得您可以在文件系统中漫步，在特定目录深度查询文件或者目录，并可对每个查询结果执行用户实现的回调方法。</li>
<li><code>java.nio.file.Path</code> 与 <code>java.nio.file.WatchService</code> 允许 “ 注册 ” 来监视特定目录。如果在目录中发生了文件创建、修改或者删除操作，监视目录的应用程序将收到通知。</li>
<li><code>java.nio.attribute.*AttributeView</code> 允许查看此前对于 Java 用户隐藏的文件和目录属性。这些属性包括文件所有者及组权限，访问控制列表（ACL），以及扩展文件属性。<a id="more"></a>
<h2 id="文件访问类"><a href="#文件访问类" class="headerlink" title="文件访问类"></a>文件访问类</h2></li>
</ul>
<p>我们的第一个例子演示了新的 <code>FileVisitor</code> API。</p>
<p>设想一个场景，您想要递归地访问一个目录树，在该树中的每个文件及目录上停下来，并为每个查找到的条目调用您自己的回调方法。在以前的 Java 版本中，这可能是个很痛苦的过程，包括递归列出目录、检查其条目、并自己调用回调。在 Java 7 中，这些都在 FileVisitor 中有提供，使用起来非常简单。</p>
<p>第一步是实现您自己的 <code>FileVisitor</code> 类。这个类包含 file-visitor 引擎穿越文件系统时所调用的回调方法。FileVisitor 接口由 5 个方法组成，在此处以遍历其间被调用的典型顺序来列出（T 在此处代表 <code>java.nio.file.Path</code> 或者超类）：</p>
<ul>
<li>在访问目录中的条目<strong>之前</strong>调用 <code>FileVisitResult preVisitDirectory(T dir)</code>。它返回一个 <code>FileVisitResult</code> 枚举值，来告诉文件访问程序 API 下一步做什么。</li>
<li>当目录由于某些原因<strong>无法访问</strong>时，调用 <code>FileVisitResult preVisitDirectoryFailed(T dir, IOException exception)</code>。在第二个参数中指出了导致访问失败的异常。</li>
<li>在当访问文件或文件夹时，调用 <code>FileVisitResult visitFile(T file, BasicFileAttributes attribs)</code>。该文件的属性传递给第二个参数。 </li>
<li>当访问文件<strong>失败</strong>时，调用 <code>FileVisitResult visitFileFailed(T file, IOException exception)</code>。第二个参数指明导致访问失败的异常。</li>
<li><strong>完成</strong>对目录及其子目录的访问后，调用 <code>FileVisitResult postVisitDirectory(T dir, IOException exception)</code>。当目录访问成功时，异常参数为空，或者包含导致目录访问过早结束的异常。</li>
</ul>
<p>为了节约开发人员的时间， NIO.2 提供了 FileVisitor 的实现接口：<code>java.nio.file.SimpleFileVisitor</code>。该类以基础方式获取：对于 <em>Failed()</em>方法，它只是重新引发该异常，并且对于其他方法，它会继续下去而根本不做任何事！它的作用在于，您可以使用匿名类来替代您所希望替代的方法；剩下的方法会按默认方式实现。</p>
<p>清单 1 展示如何创建一个 FileVisitor 实例的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FileVisitor&lt;Path&gt; myFileVisitor = <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir)</span> </span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"I'm about to visit the "</span>+dir+<span class="string">" directory"</span>); </span><br><span class="line">       <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attribs)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">       System.out.println(<span class="string">"I'm visiting file "</span>+file+<span class="string">" which has size "</span> +attribs.size());</span><br><span class="line">       <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>清单 1 中 FileVisitor 的实现，应当为其访问的每个目录和文件打印消息，并给出从其 BasicFileAttributes 中获取的文件大小。</p>
<p>接下来，我们想创建开始我们文件访问的 <code>Path</code>。利用类 <code>java.nio.Paths</code> 完成这一操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path headDir = Paths.get(<span class="string">"headDir"</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以利用两个方法中的任何一个在 类上启动树遍历：</p>
<ul>
<li><code>public static void walkFileTree(Path head, FileVisitor&lt;? super Path&gt; fileVisitor)</code> 浏览头目录下的文件树，在这一过程中调用在 <code>fileVisitor</code> 中实现的回调方法。</li>
<li><code>public static void walkFileTree(Path head, Set&lt;FileVisitOption&gt; options, int depth, FileVisitor&lt;? super Path&gt; fileVisitor)</code>与前面的方法相似，但是它给出两个附加的参数来指定访问选项，以及遍历将访问文件树中的多少个目录。</li>
</ul>
<p>我们将使用 <code>walkFileTree()</code> 方法的简单版本，来开始浏览文件数的流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.walkFileTree(headDir, myFileVisitor);</span><br></pre></td></tr></table></figure>
<p>假设目录结构是这样的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">headDir</span><br><span class="line"> |<span class="comment">--- myFile1</span></span><br><span class="line"> |<span class="comment">--- mySubDirectory1</span></span><br><span class="line"> |     \myFile2</span><br><span class="line"> \<span class="comment">--- mySubDirectory2</span></span><br><span class="line">       |<span class="comment">--- myFile3</span></span><br><span class="line">       \<span class="comment">--- mySubdirectory3</span></span><br><span class="line">             \<span class="comment">---myFile4</span></span><br></pre></td></tr></table></figure>
<p>清单 2 展示了这一例子的输出：</p>
<p>清单 2. FileVisitor 输出</p>
<blockquote>
<p>I’m about to visit the headDir directory<br>I’m about to visit the headDir\mySubDirectory2 directory<br>I’m about to visit the headDir\mySubDirectory2\mySubDirectory3 directory<br>I’m visiting file headDir\mySubDirectory2\mySubDirectory3\myFile4 which has size 2<br>I’m visiting file headDir\mySubDirectory2\myFile3 which has size 2<br>I’m about to visit the headDir\mySubDirectory1 directory<br>I’m visiting file headDir\mySubDirectory1\myFile2 which has size 2<br>I’m visiting file headDir\myFile1 which has size 2</p>
</blockquote>
<p>正如您所见到的，该文件是深度优先遍历，但不一定在任何目录内按字母顺序来进行。回调方法如期望那样被调用，我们可以看到，树中的所有文件都已列出，并且所有目录均已被访问。</p>
<p>仅利用 15 行内容，我们就创建了文件访问程序，来浏览任何您所给出的文件树，并检查包含在其中的文件。这个例子很基础，但是回调可按需地进行更加复杂的实现。</p>
<h2 id="目录监视"><a href="#目录监视" class="headerlink" title="目录监视"></a>目录监视</h2><p>第二个例子展示了新 WatchService API 及其相关类的精彩世界。</p>
<p>这一例子的场景很简单：您想要追踪特定目录（或多个目录）中是否有文件或者目录正被创建、修改、或者删除。您可能要利用这一信息来更新 GUI 显示中列示的文件，或者想检查对将要重新加载的配置文件的修改。在以前的 Java 版本中，必须实现一个代理，该代理运行在单独的线程中，来保持对目录所有内容的追踪，不断轮询文件系统来查看是否有相关的情况发生。在 Java 7 中，<code>WatchService</code> API 提供了查看目录的能力。这就免除了自己编写文件系统轮询程序的所有麻烦，并且，如果可能的话，它可基于本地系统 API 来获取更优的性能。</p>
<p>第一步是通过 <code>java.nio.file.FileSystems</code> 类创建 <code>WatchService</code> 实例。本文不涉及文件系统的细节，因此在大多数情况下，您 会希望得到默认的文件系统，然后调用其 <code>newWatchService()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatchService watchService = FileSystems.getDefault().newWatchService();</span><br></pre></td></tr></table></figure>
<p>现在我们有了自己的监视服务实例，我们想要注册到一个路径来进行监视。因为我们想要以与文件访问程序示例完全不同的方式，来为监视的目录创建一个 Path 对象，所以，我们可以在此使用其 File 实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File watchDirFile = <span class="keyword">new</span> File(<span class="string">"watchDir"</span>);</span><br><span class="line">Path watchDirPath = watchDirFile.toPath();</span><br></pre></td></tr></table></figure></p>
<p>Path 类实现 <code>java.nio.file.Watchable</code> 接口，并且该接口定义我们将在这里例子中使用的 <code>register()</code> 方法。WatchKey register(WatchService watchService, WatchEvent.Kind&lt;?&gt;… events) 通过为所给特定事件所指定的 watchService 来注册这一方法所要调用的 Path。仅当在注册调用中指定了事件时，事件才会触发一个通知。</p>
<p>对于默认的 WatchService 实现，<code>java.nio.file.StandardWatchEventKind</code> 类定义三个 java.nio.file.StandardWatchEventKind 的静态实现，这些可用于 register() 调用：</p>
<ul>
<li><code>StandardWatchEventKind.ENTRY_CREATE</code> 指出在所注册的 Path 中创建了文件或者目录。当文件重命名或者移入这一目录时，还触发了 <code>ENTRY_CREATE</code> 事件。</li>
<li><code>StandardWatchEventKind.ENTRY_MODIFY</code> 指出在所注册的 Path 中文件或者目录被修改。究竟是哪些事件组成了修改，在一定程度上是平台特定的，但是在这里只想说，其实对文件内容的修改总会触发一个修改事件。在一些平台中，变更文件的属性也会触发这一事件。</li>
<li><code>StandardWatchEventKind.ENTRY_DELETE</code> 指出在所注册的 Path 中删除了文件或者目录。当对文件重命名或者将文件移出目录时，也会触发 <code>ENTRY_DELETE</code> 事件。</li>
</ul>
<p>对于我们的例子，让我们监视 <code>ENTRY_CREATE</code> 和 <code>ENTRY_MODIFY</code> 事件，而不是 <code>ENTRY_DELETE</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WatchKey watchKey = watchDirPath.register(watchService, </span><br><span class="line">       StandardWatchEventKind.ENTRY_CREATE, StandardWatchEventKind.ENTRY_MODIFY);</span><br></pre></td></tr></table></figure>
<p>Path 现在注册为被监视，并且 WatchService 将总会一直在后台安静地工作，专心地监视目录。利用前面所展示的相同 Path 创建和 register() 调用，同一个 WatchService 实例能够监视多个目录。</p>
<p>您可能已经发现 <code>register()</code> 方法调用返回了我们以前从未遇到过的类：<code>WatchKey</code>。该类代表注册到 <code>WatchService</code>。是否挂接到这个引用由您决定，因为触发事件后，<code>WatchService</code> 会返回相关的 WatchKey。然而，要注意不存在方法调用用来找出 WatchKey 注册到哪个 目录，因此如果正在监视多个目录，您可能想要追踪哪个 WatchKey 与哪个 Path 相关。当您 在处理特定 WatchKey 及其所注册的事件时，可以很简单地通过调用 cancel() 方法，来取消其在 WatchService 的注册。</p>
<p>现在已注册了 Path，我们可以用很方便的方式来检查 WatchService，看是否发生了任何我们感兴趣的事件。WatchService 提供三个方法来检查是否有任何令人激动的事发生。</p>
<ul>
<li>如果有相关事件出现，WatchKey <code>poll()</code> 会返回下一个 <code>WatchKey</code>，或者没有注册的事件发生，会返回 <code>null</code>。</li>
<li><code>WatchKey poll(long timeout, TimeUnit unit)</code> 需要超时和时间单位（java.util.concurrent.TimeUnit）。如果在特定时间范围内，有任何事件发生，这一方法存在，会返回相应的 <code>WatchKey</code>。如果在超时时间结束时，没有 WatchKeys 返回，这一方法将会返回 <code>null</code>。</li>
<li><code>WatchKey take()</code> 与前面的方法相似，不同之处是，它将无限期等待，直到可以返回<code>WatchKey</code>。</li>
</ul>
<p>一旦这三个方法之一返回了 WatchKey，它将不会再被 <code>poll()</code> 或者 <code>take()</code> 调用返回，直到其 <code>reset()</code> 方法被调用。一旦 WatchService 返回了 WatchKey，就可以检查由于调用了 WatchKey 的 <code>pollEvents()</code> 方法而触发的事件，其将返回一列 <code>WatchEvent</code>。<br>为了便于说明，清单 3 中的简单示例仍然是来自我们前面注册的 WatchKey ：</p>
<p>清单 3. 使用 pollEvents()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a file inside our watched directory</span></span><br><span class="line">File tempFile = <span class="keyword">new</span> File(watchDirFile, <span class="string">"tempFile"</span>);</span><br><span class="line">tempFile.createNewFile();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now call take() and see if the event has been registered</span></span><br><span class="line">WatchKey watchKey = watchService.take();</span><br><span class="line"><span class="keyword">for</span> (WatchEvent&lt;?&gt; event : watchKey.pollEvents()) &#123;</span><br><span class="line">   System.out.println(</span><br><span class="line">   <span class="string">"An event was found after file creation of kind "</span> + event.kind() </span><br><span class="line">   + <span class="string">". The event occurred on file "</span> + event.context() + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当执行完成 代码3将打印出：</p>
<blockquote>
<p>An event was found after file creation of kind ENTRY_CREATE. The event occurred on file tempFile.<br>An event was found after file creation of kind ENTRY_MODIFY. The event occurred on file tempFile.</p>
</blockquote>
<p>正如您所见到的，我们得到了期望的、新创建的 <code>tempFile</code> 的 <code>ENTRY_CREATE</code> 事件，但我们还得到了其他事件。在一些操作系统中，文件的创建或删除也会产生修改事件，那么不管是什么 OS ，我们只会得到 <code>ENTRY_CREATE</code> 事件。</p>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>第三个并且是最后一个例子涉及了利用 <code>java.nio.file.attribute</code> 包中的类获取并设置文件属性的新的 API。</p>
<p>新的 API 能够提供对各种文件属性的访问。在以前的 Java 版本中，仅能得到基本的文件属性集（大小、修改时间、文件是否隐藏、以及它是文件还是目录）。为了获取或者修改更多的文件属性，必须利用运行所在平台特定的本地代码来实现，这很困难。很幸运的是，Java 7 能够允许您通过很简单的方式，利用 java.nio.file.attribute 类来读取，如果可能，修改扩展的属性集，完全去掉了这些操作的平台特定属性。</p>
<h3 id="AclFileAttributeView-与-AclEntry"><a href="#AclFileAttributeView-与-AclEntry" class="headerlink" title="AclFileAttributeView 与 AclEntry"></a>AclFileAttributeView 与 AclEntry</h3><p><code>AclFileAttributeView</code> 允许您为特定文件设置 <code>ACL</code> 及文件所有者属性。其 <code>getAcl()</code> 方法返回一个 <code>List of AclEntry</code> 对象，每个对应文件的一个权限集。其 <code>setAcl(List&lt;AclEntry&gt;)</code> 方法允许您修改该访问列表。这些属性视图仅可用于 <code>Microsoft® Windows®</code> 系统。</p>
<h3 id="BasicFileAttributeView-与-BasicFileAttributes"><a href="#BasicFileAttributeView-与-BasicFileAttributes" class="headerlink" title="BasicFileAttributeView 与 BasicFileAttributes"></a>BasicFileAttributeView 与 BasicFileAttributes</h3><p>这一视图类允许您获取一系列 —— 平常的 —— 基本文件属性，构建于以前的 Java 版本之上。其 readAttributes() 方法返回一个 BasicFileAttributes 实例，该实例包含<code>最后修改时间</code>、<code>最后访问时间</code>、<code>创建时间</code>、<code>大小</code>、以及文件属性等细节（常规文件、目录、符号链接、或者其他）。这一属性视图在所有平台上均可用。</p>
<p>我们来看一下这一视图的相关例子。为获取特定文件的文件属性视图，我们通常从为我们所感兴趣的文件创建 Path 对象开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File attribFile = <span class="keyword">new</span> File(<span class="string">"attribFile"</span>);</span><br><span class="line">Path attribPath = attribFile.toPath();</span><br></pre></td></tr></table></figure>
<p>为获取想要的文件属性视图，我们在 Path 上使用 <code>getFileAttributeView(Class viewClass)</code>方法。为获取 BasicFileAttributeView for attribPath，我们简单地调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BasicFileAttributeView basicView = attribPath.getFileAttributeView(BasicFileAttributeView.class);</span><br></pre></td></tr></table></figure></p>
<p>正如前面所描述的，为从 <code>BasicFileAttributeView</code> 获取 <code>BasicFileAttribute</code>s，我们只要调用其 <code>readAttributes()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BasicFileAttributes basicAttribs = basicView.readAttributes();</span><br></pre></td></tr></table></figure></p>
<p>那么这样就可以了，现在已经得到了您所想要的任何基本文件属性。对于 BasicFileAttributes，只有创建、最后修改、以及最后访问时间可被修改（因为改变文件大小或者类型没有意义）。为改变这些，我们可以使用 java.nio.file.attribute.FileTime 类来创建新的时间，然后在 BasicFileAttributeView 上调用 setTimes() 方法。例如，我们可以不断地更新文件的最后修改时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileTime newModTime </span><br><span class="line">    = FileTime.fromMillis(basicAttribs.lastModifiedTime().toMillis() + <span class="number">60000</span>);</span><br><span class="line"> basicView.setTimes(newModTime, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这两个 null 指出，我们不想改变这一文件的最后访问时间或者创建时间。如果以前面相同的方式再次检查基本属性，您会发现最后修改时间已被修改，但是创建时间和最后访问时间还保持原样。</p>
<h3 id="DosFileAttributeView-与-DosFileAttributes"><a href="#DosFileAttributeView-与-DosFileAttributes" class="headerlink" title="DosFileAttributeView 与 DosFileAttributes"></a>DosFileAttributeView 与 DosFileAttributes</h3><p>这一视图类允许您获取指定给 DOS 的属性。（您可能会猜想，这一视图仅用于 Windows 系统。）其 readAttributes() 方法返回一个 DosFileAttributes 实例，该实例包含有问题的文件是否为只读、隐藏、系统文件、以及存档文件等细节信息。这一视图还包含针对每个属性的 set*(boolean) 方法。</p>
<h3 id="FileOwnerAttributeView-与-UserPrincipal"><a href="#FileOwnerAttributeView-与-UserPrincipal" class="headerlink" title="FileOwnerAttributeView 与 UserPrincipal"></a>FileOwnerAttributeView 与 UserPrincipal</h3><p>这一视图类允许您获取并设置特定文件的所有者。其 <code>getOwner()</code>方法返回一个 <code>UserPrincipal</code>（还处于 java.nio.file.attribute 包中），其又具有 getName() 方法，来返回包含所有者名字的 String。该视图还提供     <code>setOwner(UserPrincipal)</code> 方法用于变更文件所有者。该视图在所有平台上都可用。</p>
<h3 id="FileStoreSpaceAttributeView-与-FileStoreSpaceAttributes"><a href="#FileStoreSpaceAttributeView-与-FileStoreSpaceAttributes" class="headerlink" title="FileStoreSpaceAttributeView 与 FileStoreSpaceAttributes"></a>FileStoreSpaceAttributeView 与 FileStoreSpaceAttributes</h3><p>允许您获取有关特定文件存储的信息。其 readAttributes() 方法返回一个包含文件存储的整个空间、未分配空间、以及已使用空间细节的 FileStoreSpaceAttributes 实例。这一视图在所有平台上都可用。</p>
<h3 id="PosixFileAttributeView-与-PosixFileAttributes"><a href="#PosixFileAttributeView-与-PosixFileAttributes" class="headerlink" title="PosixFileAttributeView 与 PosixFileAttributes"></a>PosixFileAttributeView 与 PosixFileAttributes</h3><p>这一视图类，仅在 UNIX® 系统上可用，允许您获取并设置指定给 <code>POSIX（Portable Operating System Interface）</code>的属性。其 <code>readAttributes()</code>方法返回一个包含有关这一文件的所有者、组所有者、以及这一文件许可（这些细节通常用 UNIX chmod 命令设置）的 PosixFileAttributes 实例。这一视图还提供 <code>setOwner(UserPrincipal)</code>、 <code>setGroup(GroupPrincipal)</code>、以及 <code>setPermissions(Set&lt;PosixFilePermission&gt;)</code> 来修改这些属性。</p>
<h3 id="UserDefinedFileAttributeView-与-String"><a href="#UserDefinedFileAttributeView-与-String" class="headerlink" title="UserDefinedFileAttributeView 与 String"></a>UserDefinedFileAttributeView 与 String</h3><p>这一视图类，仅可用于 Windows，允许您获取并设置文件的扩展属性。 这些属性跟其他的不同，它们只是名称值对，并可按需对其进行设置。 如果想向文件增加一些隐藏的元数据，而不必修改文件内容，这就很有用了。 这一属性提供 list() 方法，来为相关的文件返回 List of String 扩展属性的名字。</p>
<p>有了其名字后，就要获取特定属性的内容，这一视图具有一个 <code>size(String name)</code> 方法来返回属性值的大小，以及一个 <code>read(String name, ByteBuffer dest)</code> 方法来将属性值读取到 ByteBuffer 中。这一视图还提供 <code>write(String name, ByteBuffer source)</code> 方法来创建或者修改属性，以及一个 <code>delete(String name)</code> 方法来完全移除现有的属性。</p>
<p>这可能是最有趣的新属性视图，因为它允许您利用任意 String 名字和 ByteBuffer 值向文件增加属性。这很对 —— 其值是个 ByteBuffer，因此您可以在这里存储任何二进制数据。<br>首先，我们将会获取属性视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserDefinedFileAttributeView userView </span><br><span class="line">    = attribPath.getFileAttributeView(UserDefinedFileAttributeView.class);</span><br></pre></td></tr></table></figure></p>
<p>为获取用户为这一文件定义的属性名，我们在视图上调用 list() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; attribList = userView.list();</span><br></pre></td></tr></table></figure></p>
<p>一旦我们拥有了想得到相关值的特定属性名，就为该值分配一个大小合适的 ByteBuffer，然后调用视图的 read(String, ByteBuffer) 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer attribValue = ByteBuffer.allocate(userView.size(attribName));</span><br><span class="line">userView.read(attribName, attribValue);</span><br></pre></td></tr></table></figure></p>
<p>attribValue 现在包含了为那一特定属性所存储的任何数据。 想设置自己的属性，只需创建 ByteBuffer 并按需填入数据，然后在视图上调用 <code>write(String, ByteBuffer)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userView.write(attribName, attribValue);</span><br></pre></td></tr></table></figure></p>
<p>写入属性，或者创建该属性，或者利用相同的名字覆盖已有的属性。</p>
<p>这样，我们结束第三个而且是最后一个例子。演示这四个属性视图（BasicFileAttributeView、FileOwnerAttributeView、FileStoreSpaceAttributeView、以及 UserDefinedAttributeView）的完整示例代码包含在 下载 的示例代码中。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>除了本文所提到的以外，还有很多其他的 NIO.2 文件 API。Java 7 具有创建、检查、并修改符号链接的新功能。还有新的类，来允许访问文件系统的低级信息，并支持提供者（称为 <code>FileSystem</code> 和 <code>FileStore</code>）访问任何想要访问的文件系统。</p>
<p>总之，NIO.2 为 Java 开发人员提供了一系列简单、兼容、并且功能强大的 API，来与文件系统交互。其目的是抽取处理文件和目录时所涉及的复杂的、平台特定的细节，并能较好地为程序员提供更强大的功能和更多的灵活性。</p>
<h2 id="转载自："><a href="#转载自：" class="headerlink" title="转载自："></a>转载自：</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-nio2-2/index.html" target="_blank" rel="noopener">文件系统 API -Catherine Hope 和 Oliver Deakin</a>  </li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
    <div>    
       
       
      <ul class="post-copyright">
        <li class="post-copyright-author">
            <strong>本文作者：</strong>onlyxx
        </li>
        <li class="post-copyright-link">
          <strong>本文链接：</strong>
          <a href="/posts/481587f.html" title="NIO2笔记+搬运">posts/481587f.html</a>
        </li>
        <li class="post-copyright-license">
          <strong>版权： </strong>
          本站文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议，请勿用于商业，转载注明出处！
        </li>
      </ul>
     
    </div>
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/6558eb68.html" rel="next" title="SAP BW使用RRW3_GET_QUERY_VIEW_DATA获取数据">
                <i class="fa fa-chevron-left"></i> SAP BW使用RRW3_GET_QUERY_VIEW_DATA获取数据
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/f85ee54b.html" rel="prev" title="centos安装Nginx并配置https转发">
                centos安装Nginx并配置https转发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://c.disquscdn.com/uploads/users/32736/3375/avatar92.jpg?1547107149" alt="onlyxx">
            
              <p class="site-author-name" itemprop="name">onlyxx</p>
              <p class="site-description motion-element" itemprop="description">write some content</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zuoliang0" title="GitHub &rarr; https://github.com/zuoliang0" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#导言"><span class="nav-number">1.</span> <span class="nav-text">导言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件访问类"><span class="nav-number">2.</span> <span class="nav-text">文件访问类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录监视"><span class="nav-number">3.</span> <span class="nav-text">目录监视</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件属性"><span class="nav-number">4.</span> <span class="nav-text">文件属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AclFileAttributeView-与-AclEntry"><span class="nav-number">4.1.</span> <span class="nav-text">AclFileAttributeView 与 AclEntry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BasicFileAttributeView-与-BasicFileAttributes"><span class="nav-number">4.2.</span> <span class="nav-text">BasicFileAttributeView 与 BasicFileAttributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DosFileAttributeView-与-DosFileAttributes"><span class="nav-number">4.3.</span> <span class="nav-text">DosFileAttributeView 与 DosFileAttributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileOwnerAttributeView-与-UserPrincipal"><span class="nav-number">4.4.</span> <span class="nav-text">FileOwnerAttributeView 与 UserPrincipal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileStoreSpaceAttributeView-与-FileStoreSpaceAttributes"><span class="nav-number">4.5.</span> <span class="nav-text">FileStoreSpaceAttributeView 与 FileStoreSpaceAttributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PosixFileAttributeView-与-PosixFileAttributes"><span class="nav-number">4.6.</span> <span class="nav-text">PosixFileAttributeView 与 PosixFileAttributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UserDefinedFileAttributeView-与-String"><span class="nav-number">4.7.</span> <span class="nav-text">UserDefinedFileAttributeView 与 String</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束语"><span class="nav-number">5.</span> <span class="nav-text">结束语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转载自："><span class="nav-number">6.</span> <span class="nav-text">转载自：</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-address-card-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">onlyxx</span>

  

  
</div>






  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
      
    
  
  <script color="0,0,125" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  
    
  <script id="dsq-count-scr" src="https://zze.disqus.com/count.js" async></script>


<script>
  var disqus_config = function () {
    this.page.url = "https://blog.zzl.ink/posts/481587f.html";
    this.page.identifier = "posts/481587f.html";
    this.page.title = 'NIO2笔记+搬运';
    };
  function loadComments () {
    var d = document, s = d.createElement('script');
    s.src = 'https://zze.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    loadComments();
  
</script>

  





  





  

  

  

  

  

  

  

  

  

  

  

  

  

  <!-- 每日诗词 -->
<script type="text/javascript" src="https://sdk.jinrishici.com/v2/browser/jinrishici.js"></script>
</body>
</html>
